### Примечание

Обычно я создаю глобальный обработчик ошибок, возвращающий JSON с описанием ошибок. 
Но здесь заморачиваться не стал, для тестового задания это лишняя трата времени.
Поэтому, в случае ошибки Spring сам вернет JSON с ошибкой. 


### Запуск Swagger UI

```shell
mvn clean package
java -jar target/test-sort-0.0.1-SNAPSHOT.jar
```

Далее переходим на: http://localhost:8080/swagger-ui.html



### Недостатки.

1. Неоптимальный выбор опорного значения (pivot). Может сильно увеличить сложность в случаях (частично) отсортированных массивов. 
2. Не учтены дубли чисел. Это недостаток описания ТЗ :)
3. Не учтено, что в эксел числа могут писаться в виде строки.
4. Не учтены большие файлы, для которых лучше изменить загрузку на стрим (SXSSFWorkbook) и соответственно алгоритм нахождения минимума.


### Улучшения.

#### 1. Pivot.
Вопрос о выборе pivot довольно спорный и нет универсального варианта на все случаи жизни. 
Идеальный pivot - это медиана значений массива. Только вот получить её требует затрат и 
наверное никогда не оправданно.  
Поэтому берут его почти наугад. Кто-то крайнее значение массива (как делал я),
кто-то из середины. Крайнее значение плохо на отсортированных массивах, но и значение
из середины может привести к O(n^2) в случае если там хранилось граничное значение.  
Видел даже как pivot берут рандомно, что на мой взгляд как-то слишком рискованно.  
Если уж хочется избежать самых тяжелых случаев, то можно брать его по 
трем значениям массива:
```java
int pivot = medianOfThree(array[left], array[left + (right - left) / 2], array[right]);
...
private static int medianOfThree(int a, int b, int c) {
    if ((b >= a && b <= c) || (b >= c && b <= a))
        return b;
    else if ((a >= b && a <= c) || (a >= c && a <= b))
        return a;
    else return c;
}
```
Это почти 100% гарантия избежать O(n^2) и значительно увеличивает шансы на приближение
к сложности O(n).


#### 2. Дубли чисел.

Можно просто читать значения из файла во множество, а на выходе возвращать список.
Операция не сильно затратная на массивах средней величины, зато алгоритм не нужно менять.

#### 3. Числа в строковом виде.

Это исправляется еще проще:
```java
try (FileInputStream fis = new FileInputStream(path);
     Workbook workbook = new XSSFWorkbook(fis)) {
    Sheet sheet = workbook.getSheetAt(0);
    for (Row row : sheet) {
        Cell cell = row.getCell(0);
        if (cell != null) {
            switch (cell.getCellType()) {
                case NUMERIC -> numbers.add((int) cell.getNumericCellValue());
                case STRING -> {
                    try {
                        numbers.add(Integer.parseInt(cell.getStringCellValue().trim()));
                    } catch (NumberFormatException ignored) {}
                }
            }
        }
    }
}
```

#### 4. Большие файлы.

Здесь не только нужно переходить на стрим, но и сам алгоритм поиска минимума менять на более подходящий.


## Оптимизированный алгоритм.

Добавил QuickSelectFast, использующий вместо рекурсии циклы.
